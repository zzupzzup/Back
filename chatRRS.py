# -*- coding: utf-8 -*-
"""ChatRRS_0510.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eI25Vj7Ntb__7KeoQ7yTMBqKNfjVw-ZJ
"""


from sentence_transformers import SentenceTransformer, util
import pandas as pd
import time
from tqdm import tqdm
import numpy as np
import pickle
import faiss
import json

import torch
from fastapi import APIRouter, Depends
from models import ChatRRS_Detail_Item
from sqlalchemy import create_engine, text
from app.common.config import LocalConfig
from sqlalchemy.orm import Session
from app.database.conn import db
from app.database.schema import Stores, Reviews
from models import ChatRRS_Detail_Item
import json
from sqlalchemy.sql import text

from os import path
from connectS3 import upload_to_aws, download_from_aws
from fastapi.responses import JSONResponse


# 이 파일의 데이터인 review_0510_1655.csv, encoded_data_0510_1925.npy 는 s3 에 저장되기 때문에 
# response_model 을 쓸 수가 없다. return 형식을 함수 내에서 정의해서 output 을 뱉음 -> 나중에 response_model 쓸 수 있게 바꿀 예정.

router = APIRouter() 

cpu_device = torch.device("cpu") 

# Check
# 리뷰정보 가져오는 곳 바꾸기
# 파일명 review_0510_1655.csv
engine = create_engine(LocalConfig.DB_URL)

if path.exists('review_0510_1655.csv') == False:
          download_from_aws('review_0510_1655.csv', 'zzup-s3-bucket', 'review_0510_1655.csv')

DF =  pd.read_csv('review_0510_1655.csv')
#DF =  pd.read_csv('/Users/hwangjaesung/Documents/capstone/Back/review_0510_1655.csv')

def fetch_store_info(idxs,scores):
    
    dataframe = DF
    info = dataframe.loc[idxs,['store','reviewtext']]
    info['score']=scores
    info_df = pd.DataFrame(info)

    info_df.drop_duplicates(subset=['store'],inplace=True)
    
    info_df = info_df[info_df['score']>=60]

    # Check
    # 가게정보 가져오는 부분 바꾸기
    # 파일명 store_0507_1614.csv
    query_store = 'SELECT * FROM stores'
    store = pd.read_sql_query(sql=text(query_store), con=engine.connect())
    
    info_df_merge = info_df.merge(store,left_on='store',right_on='store',how='left')
        
    cnt = len(info_df_merge.loc[info_df_merge['score'] >= 0.7])
    
    top_n = cnt
    results = info_df_merge[['store','address','reviewtext','score','category']].head(top_n)
    
    results['score'] = results['score'].apply(lambda x : 99 if x >= 99 else x)
        
    return results

def search(query: str):
    model = SentenceTransformer('jhgan/ko-sroberta-multitask',device=cpu_device)
    
    if path.exists('encoded_data_0510_1925.npy') == False:
          download_from_aws('encoded_data_0510_1925.npy', 'zzup-s3-bucket', 'encoded_data_0510_1925.npy')
    encoded_data = np.load('encoded_data_0510_1925.npy') 
    
    #encoded_data = np.load('/Users/hwangjaesung/Documents/capstone/Back/encoded_data_0510_1925.npy')

    index = faiss.IndexIDMap(faiss.IndexFlatIP(768))
    index.add_with_ids(encoded_data,np.array(range(0,len(DF))))
    
    query_vector = model.encode([query])
    
    top_k = 100
    top_k = index.search(query_vector, top_k)

    top_k_sim_score = top_k[0].tolist()[0]

    top_k_ids = top_k[1].tolist()[0]
    top_k_ids = list(np.unique(top_k_ids))

    search_dict ={}
    search_dict['idxs'] = top_k_ids
    search_dict['scores'] = top_k_sim_score
    
    return search_dict
  
@router.post('/chatRRS', status_code=200) 
async def chatrrsModel(query : str, db : Session = Depends(db.session)): 
  search_dict = search(query)
  results = fetch_store_info(**search_dict)
  final = results.to_dict(orient='records')

  if len(results) ==0 :
    JSONResponse(status_code=400, content=dict(msg="NO_RESULT"))
  
  store_list = []
  for i in results['store']:
    store_list.append(i)
     
  store_info = []
  for store in store_list:
    store_info.append(db.query(Stores).filter(Stores.store == store).first())
    
  for i, v in enumerate(store_info):
    final[i]['id'] = v.id
    
  return final

# @router.post('/chatRRS/detail/{id}', status_code = 201)
# async def chatrrsModel_detail(id : int, db : Session = Depends(db.session)):
#   store = db.query(Stores).filter(Stores.id == id ).first().store
  
#   store_review = db.query(Reviews).filter(Reviews.store == store).all()
#   reviewtext = []
#   for i in store_review:
#        reviewtext.append(i.reviewtext)
  
#   storeid = db.query(Stores).filter(Stores.store == store).first().id
#   img_url = db.query(Stores).filter(Stores.store == store).first().img_url
#   store_name = db.query(Stores).filter(Stores.store == store).first().store
  
#   final = {}
#   final['id'] = storeid
#   final['store'] = store_name
#   final['img_url'] = img_url
#   final['reviewtext'] = reviewtext
  
#   return final
   